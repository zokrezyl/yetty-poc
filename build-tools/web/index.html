<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yetty - WebGPU Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0f0f23;
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        canvas {
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #eee;
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
        }
        #loading .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #status {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div id="loading">
            <div class="spinner"></div>
            <div>Loading WebGPU...</div>
            <div id="status"></div>
        </div>
    </div>

    <script>
        // Toybox WASM module factory
        let ToyboxFactory = null;
        let toyboxInstance = null;  // Persistent Toybox instance with synced FS
        let commandHistory = [];
        let historyIndex = -1;

        const AVAILABLE_COMMANDS = [
            'ls', 'cat', 'head', 'tail', 'touch', 'mkdir', 'rmdir', 'rm', 'cp', 'mv', 'find',
            'echo', 'printf', 'pwd', 'printenv', 'env', 'test', 'true', 'false',
            'wc', 'sort', 'uniq', 'cut', 'tr', 'rev', 'basename', 'dirname', 'tee',
            'yes', 'seq', 'cal', 'factor', 'sleep', 'date'
        ];

        // Recursively copy directory from yetty's FS to Toybox's FS
        function syncDirectoryToToybox(toybox, srcPath) {
            if (!Module.FS || !toybox.FS) {
                console.error('syncDirectoryToToybox: FS not available', {yettyFS: !!Module.FS, toyboxFS: !!toybox.FS});
                return;
            }

            try {
                const entries = Module.FS.readdir(srcPath);
                console.log('Syncing', srcPath, 'entries:', entries.length - 2); // -2 for . and ..
                for (const entry of entries) {
                    if (entry === '.' || entry === '..') continue;

                    const fullPath = srcPath + '/' + entry;
                    const stat = Module.FS.stat(fullPath);

                    if (Module.FS.isDir(stat.mode)) {
                        try { toybox.FS.mkdir(fullPath); } catch (e) {}
                        syncDirectoryToToybox(toybox, fullPath);
                    } else if (Module.FS.isFile(stat.mode)) {
                        try {
                            const data = Module.FS.readFile(fullPath);
                            toybox.FS.writeFile(fullPath, data);
                        } catch (e) {
                            console.warn('Failed to sync file:', fullPath, e);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to read directory:', srcPath, e);
            }
        }

        async function initToybox() {
            const status = document.getElementById('status');
            const loading = document.getElementById('loading');

            if (status) status.textContent = 'Loading Toybox...';

            try {
                const script = document.createElement('script');
                script.src = 'toybox.js';

                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = () => reject(new Error('Failed to load toybox.js'));
                    document.head.appendChild(script);
                });

                ToyboxFactory = ToyboxModule;
                if (status) status.textContent = 'Toybox ready!';

                setTimeout(() => {
                    if (loading) loading.style.display = 'none';
                }, 500);

            } catch (err) {
                if (status) status.textContent = 'Error: ' + err.message;
                console.error('Failed to initialize Toybox:', err);
            }
        }

        async function getToyboxInstance() {
            if (toyboxInstance) return toyboxInstance;

            if (!ToyboxFactory) return null;

            // Create persistent Toybox instance
            toyboxInstance = await ToyboxFactory({
                thisProgram: 'toybox',
                print: () => {},  // Will be overridden per-command
                printErr: () => {},
                noExitRuntime: true,
            });

            // Sync demo and assets directories from yetty's FS
            try {
                toyboxInstance.FS.mkdir('/demo');
            } catch (e) {}
            try {
                toyboxInstance.FS.mkdir('/assets');
            } catch (e) {}

            syncDirectoryToToybox(toyboxInstance, '/demo');
            syncDirectoryToToybox(toyboxInstance, '/assets');

            console.log('Toybox filesystem synced with yetty');
            return toyboxInstance;
        }

        // Pre-allocated buffer for terminal writes (avoids malloc/free per keypress)
        let termWriteBuffer = null;
        const TERM_BUFFER_SIZE = 4096;

        function writeToTerminal(text) {
            if (typeof Module._yetty_write !== 'function') return;
            
            // Lazy-init the buffer once Module is ready
            if (!termWriteBuffer && typeof Module._malloc === 'function') {
                termWriteBuffer = Module._malloc(TERM_BUFFER_SIZE);
            }
            if (!termWriteBuffer) return;

            const len = Math.min(text.length, TERM_BUFFER_SIZE - 1);
            for (let i = 0; i < len; i++) {
                Module.HEAPU8[termWriteBuffer + i] = text.charCodeAt(i);
            }
            Module.HEAPU8[termWriteBuffer + len] = 0;
            Module._yetty_write(termWriteBuffer, len);
        }

        let commandBuffer = '';

        function setupCanvasInput() {
            const canvas = document.getElementById('canvas');
            canvas.tabIndex = 0;
            canvas.focus();

            canvas.addEventListener('keydown', async (e) => {
                e.preventDefault();

                if (e.key === 'Enter') {
                    const cmd = commandBuffer.trim();
                    commandBuffer = '';
                    writeToTerminal('\r\n');

                    if (cmd) {
                        await runToyboxCommand(cmd);
                    }
                    writeToTerminal('$ ');
                } else if (e.key === 'Backspace') {
                    if (commandBuffer.length > 0) {
                        commandBuffer = commandBuffer.slice(0, -1);
                        writeToTerminal('\b \b');
                    }
                } else if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                    // Regular character - echo directly
                    commandBuffer += e.key;
                    writeToTerminal(e.key);
                }
            });

            canvas.addEventListener('click', () => canvas.focus());

            let currentScale = 1.0;
            canvas.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    currentScale = Math.max(0.3, Math.min(3.0, currentScale + delta));
                    if (typeof Module._yetty_set_scale === 'function') {
                        Module._yetty_set_scale(currentScale);
                    }
                }
            }, { passive: false });
        }

        async function runToyboxCommand(cmdLine) {
            if (cmdLine.trim()) {
                commandHistory.push(cmdLine);
                historyIndex = commandHistory.length;
            }

            const parts = cmdLine.trim().split(/\s+/);
            const cmd = parts[0];

            if (cmd === 'help') {
                writeToTerminal('Available commands:\r\n');
                writeToTerminal('  ' + AVAILABLE_COMMANDS.join(', ') + '\r\n');
                writeToTerminal('  help  - Show this help\r\n');
                writeToTerminal('  clear - Clear screen\r\n');
                return;
            }

            if (cmd === 'clear') {
                writeToTerminal('\x1b[2J\x1b[H');
                return;
            }

            if (!ToyboxFactory) {
                writeToTerminal('Error: Toybox not loaded yet\r\n');
                return;
            }

            if (!AVAILABLE_COMMANDS.includes(cmd)) {
                writeToTerminal(`'${cmd}' is not available.\r\n`);
                return;
            }

            try {
                // Create fresh Toybox instance and sync filesystem from yetty
                const mod = await ToyboxFactory({
                    thisProgram: 'toybox',
                    print: (text) => writeToTerminal(text + '\r\n'),
                    printErr: (text) => writeToTerminal('\x1b[31m' + text + '\x1b[0m\r\n'),
                    noExitRuntime: true,
                });

                // Sync demo and assets directories from yetty's FS to this Toybox instance
                if (Module.FS && mod.FS) {
                    try { mod.FS.mkdir('/demo'); } catch (e) {}
                    try { mod.FS.mkdir('/assets'); } catch (e) {}
                    syncDirectoryToToybox(mod, '/demo');
                    syncDirectoryToToybox(mod, '/assets');
                }

                mod.callMain(parts);
            } catch (err) {
                if (!err.message?.includes('exit') && !err.message?.includes('unreachable')) {
                    writeToTerminal('Error: ' + err.message + '\r\n');
                }
            }
        }

        async function checkWebGPU() {
            const status = document.getElementById('status');

            if (!navigator.gpu) {
                status.textContent = 'WebGPU not supported in this browser';
                document.getElementById('loading').innerHTML = `
                    <div style="color: #e94560;">WebGPU Not Supported</div>
                    <div style="margin-top: 10px; font-size: 0.9em;">
                        Try Chrome/Edge 113+ or Firefox Nightly with WebGPU enabled.
                    </div>
                `;
                return false;
            }

            try {
                status.textContent = 'Requesting WebGPU adapter...';
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    status.textContent = 'No WebGPU adapter found';
                    return false;
                }

                status.textContent = 'Requesting WebGPU device...';
                const device = await adapter.requestDevice();
                if (!device) {
                    status.textContent = 'Failed to get WebGPU device';
                    return false;
                }

                Module.preinitializedWebGPUDevice = device;
                status.textContent = 'WebGPU initialized';
                console.log('WebGPU device ready:', device);
                return true;
            } catch (err) {
                status.textContent = 'WebGPU error: ' + err.message;
                console.error('WebGPU initialization error:', err);
                return false;
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('canvas');
            if (container && canvas) {
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                if (typeof Module !== 'undefined' && typeof Module._yetty_resize === 'function') {
                    Module._yetty_resize(rect.width, rect.height);
                }
            }
        }

        let moduleReadyResolve;
        const moduleReady = new Promise(resolve => { moduleReadyResolve = resolve; });

        var Module = {
            canvas: document.getElementById('canvas'),
            print: function(text) { console.log('[yetty]', text); },
            printErr: function(text) { console.error('[yetty]', text); },
            onRuntimeInitialized: function() {
                console.log('yetty runtime initialized');
                const status = document.getElementById('status');
                const loading = document.getElementById('loading');
                if (status) status.textContent = 'yetty ready!';
                setTimeout(() => {
                    if (loading) loading.style.display = 'none';
                }, 500);
                resizeCanvas();
                moduleReadyResolve();

                setTimeout(() => {
                    writeToTerminal('$ ');
                    if (typeof Module._yetty_sync === 'function') {
                        Module._yetty_sync();
                    }
                    setupCanvasInput();
                }, 100);
            }
        };

        window.addEventListener('resize', resizeCanvas);

        async function initYetty() {
            const status = document.getElementById('status');
            if (status) status.textContent = 'Loading yetty...';

            try {
                const script = document.createElement('script');
                script.src = 'yetty.js';

                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = () => reject(new Error('Failed to load yetty.js'));
                    document.head.appendChild(script);
                });

                console.log('yetty.js loaded');
                return true;
            } catch (err) {
                console.error('Failed to load yetty:', err);
                if (status) status.textContent = 'yetty error: ' + err.message;
                return false;
            }
        }

        async function init() {
            resizeCanvas();
            const hasWebGPU = await checkWebGPU();

            if (hasWebGPU) {
                const yettyOk = await initYetty();
                if (!yettyOk) {
                    console.warn('yetty failed to initialize');
                }
            }

            await initToybox();
        }

        init();
    </script>
</body>
</html>
